[{"content":"\u003cp\u003eOptimizing performance is an important aspect of software development, especially in embedded systems where resources are constrained. In this blog, I’ll walk you through how I achieved a 50x speedup in \u003ccode\u003eidf_size.py\u003c/code\u003e, a Python script within the popular \u003ca href=\"https://github.com/espressif/esp-idf\"\u003eEspressif IoT Development Framework (ESP-IDF)\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis transformation not only improved developer workflows but also highlighted the power of targeted optimizations.\u003c/p\u003e\n\u003ch1 id=\"background\"\u003eBackground\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003eidf_size.py\u003c/code\u003e plays a crucial role in analyzing memory usage for ESP32 firmware, focusing on the efficient utilization of limited resources like Instruction RAM (IRAM) and Data RAM (DRAM). While essential for optimizing firmware, the script\u0026rsquo;s slow execution time, particularly when processing large \u003ccode\u003e.map\u003c/code\u003e files, hindered developer workflows and productivity.\u003c/p\u003e\n\u003ch2 id=\"the-problem\"\u003eThe Problem\u003c/h2\u003e\n\u003cp\u003eParsing a 15MB \u003ccode\u003e.map\u003c/code\u003e file took nearly 20 seconds, causing delays during builds and reducing productivity. My goal was to eliminate this bottleneck while maintaining accuracy.\u003c/p\u003e\n\u003ch1 id=\"original-performance-and-bottlenecks\"\u003eOriginal Performance and Bottlenecks\u003c/h1\u003e\n\u003ch2 id=\"legacy-code-performance\"\u003eLegacy Code Performance\u003c/h2\u003e\n\u003cp\u003eRunning \u003ccode\u003eidf_size.py\u003c/code\u003e on a 15MB \u003ccode\u003e.map\u003c/code\u003e file yielded the following results:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eanthony@linux:~/esp/esp-idf/tools$ time ./idf\u003cspan style=\"color:#ae81ff\"\u003e\\_\u003c/span\u003esize.py /tmp/firmware.map  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ereal    0m19.440s  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003euser    0m19.395s  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esys     0m0.044s\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAn execution time nearing 20 seconds made the script impractical for frequent use.\u003c/p\u003e\n\u003ch2 id=\"bottlenecks-identified\"\u003eBottlenecks Identified\u003c/h2\u003e\n\u003cp\u003eThrough careful analysis, the following issues were identified as the primary causes of slow performance in \u003ccode\u003eidf_size.py\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eInefficient Regular Expressions:\u003c/strong\u003e The script relied on complex regex patterns, some with unnecessary wildcards, which significantly slowed down pattern matching.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRedundant Regex Evaluations:\u003c/strong\u003e Multiple regexes were applied to the same line, duplicating effort and increasing processing time unnecessarily.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLack of Filtering Mechanisms:\u003c/strong\u003e Every line of the \u003ccode\u003e.map\u003c/code\u003e file was processed, even those irrelevant to memory usage analysis, adding unnecessary overhead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBy addressing these bottlenecks, I was able to dramatically reduce the runtime and make the script far more efficient.\u003c/p\u003e\n\u003ch1 id=\"in-depth-analysis-of-optimizations\"\u003eIn-Depth Analysis of Optimizations\u003c/h1\u003e\n\u003cp\u003eTo tackle the identified bottlenecks, I implemented a series of targeted optimizations. Each optimization addressed specific inefficiencies in the script, from improving regular expression performance to minimizing unnecessary computations. These changes were iterative, with each step building upon the previous improvements to achieve the final result.\u003c/p\u003e\n\u003ch2 id=\"pre-compiling-regexes\"\u003ePre-Compiling Regexes\u003c/h2\u003e\n\u003cp\u003eWhile some \u003ca href=\"https://stackoverflow.com/questions/452104/is-it-worth-using-pythons-re-compile\"\u003ehave argued\u003c/a\u003e over the true performance gains of using \u003ccode\u003ere.compile\u003c/code\u003e due to the fact that the first time you call \u003ccode\u003ere.match\u003c/code\u003e, it will perform a compilation and store it in a cache, there are still a few key benefits to using it here.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eUsing \u003ccode\u003ere.compile\u003c/code\u003e provides more readable code due to the fact that it allows you to assign a name to the compiled object and use it directly, rather than as a parameter in a function call:\u003c/p\u003e\n\u003ch4 id=\"original-code\"\u003eOriginal Code\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eRE_MEMORY_SECTION \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003er\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;(?P\u0026lt;name\u0026gt;[^ ]+) +0x(?P\u0026lt;origin\u0026gt;[\\da-f]+) +0x(?P\u0026lt;length\u0026gt;[\\da-f]+)\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003em \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e re\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ematch\u003c/span\u003e(RE_MEMORY_SECTION, line)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"optimized-code\"\u003eOptimized Code\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eRE_MEMORY_SECTION \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e re\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ecompile(\u003cspan style=\"color:#e6db74\"\u003er\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;(?P\u0026lt;name\u0026gt;[^ ]+) +0x(?P\u0026lt;origin\u0026gt;[\\da-f]+) +0x(?P\u0026lt;length\u0026gt;[\\da-f]+)\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003em \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e RE_MEMORY_SECTION\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ematch\u003c/span\u003e(line)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePre-compiled regexes will bypass the cache entirely, meaning they will avoid having to make cache lookups on every usage, and are not limited by the maximum cache size available.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"optimized-regex\"\u003eOptimized Regex\u003c/h2\u003e\n\u003cp\u003eThe most significant performance gain came from optimizing the \u003ccode\u003eRE_SOURCE_LINE\u003c/code\u003e regex. I noticed an extra unneeded wildcard after the symbol name, which slowed down the matching process. By removing this wildcard, the regex became immensely more efficient. This optimization alone brought the execution time down to approximately 1.4 seconds! Despite this substantial gain, additional opportunities for optimization remained.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#                                      |\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#                                      V\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eRE_SOURCE_LINE \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003er\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\\s*(?P\u0026lt;sym_name\u0026gt;\\S*).* +0x(?P\u0026lt;address\u0026gt;[\\da-f]+) +0x(?P\u0026lt;size\u0026gt;[\\da-f]+) (?P\u0026lt;archive\u0026gt;.+\\.a)?\\(?P\u0026lt;object_file\u0026gt;.+\\.(o|obj))?\\)\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"combining-regexes\"\u003eCombining Regexes\u003c/h2\u003e\n\u003cp\u003eI noticed that the code was using 2 distinct regexes which looked very similar. I was able to optimize the performance even further by combining these two into a single regex, avoid the overhead of calling \u003ccode\u003eregex.match()\u003c/code\u003e twice. It was as simple as making the \u003ccode\u003earchive\u003c/code\u003e named group be optional. This change alone resulted in cutting the processing time in half even without removing the extra wildcard!\u003c/p\u003e\n\u003ch4 id=\"original-code-1\"\u003eOriginal Code\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eRE_SOURCE_LINE = r\u0026#34;\\s*(?P\u0026lt;sym_name\u0026gt;\\S*).* +0x(?P\u0026lt;address\u0026gt;[\\da-f]+) +0x(?P\u0026lt;size\u0026gt;[\\da-f]+) (?P\u0026lt;archive\u0026gt;.+\\.a)\\((?P\u0026lt;object_file\u0026gt;.+\\.ob?j?)\\)\u0026#34;\nm = re.match(RE_SOURCE_LINE, line, re.M)\nif not m:\n   RE_SOURCE_LINE = r\u0026#34;\\s*(?P\u0026lt;sym_name\u0026gt;\\S*).* +0x(?P\u0026lt;address\u0026gt;[\\da-f]+) +0x(?P\u0026lt;size\u0026gt;[\\da-f]+) (?P\u0026lt;object_file\u0026gt;.+\\.ob?j?)\u0026#34;\n   m = re.match(RE_SOURCE_LINE, line)\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"optimized-code-1\"\u003eOptimized Code\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eRE_SOURCE_LINE \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e re\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ecompile(\u003cspan style=\"color:#e6db74\"\u003er\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\\s*(?P\u0026lt;sym_name\u0026gt;\\S*) +0x(?P\u0026lt;address\u0026gt;[\\da-f]+) +0x(?P\u0026lt;size\u0026gt;[\\da-f]+) (?P\u0026lt;archive\u0026gt;.+\\.a)?\\(?(?P\u0026lt;object_file\u0026gt;.+\\.(o|obj))\\)?\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003em \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e RE_SOURCE_LINE\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ematch\u003c/span\u003e(line)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"pre-filtering-mechanism\"\u003ePre-filtering Mechanism\u003c/h2\u003e\n\u003cp\u003eSince I knew that the \u003ccode\u003eRE_SOURCE_LINE\u003c/code\u003e regex was the slowest part of the code, I wanted to design ways to avoid calling it. This is why I introduced a pre-filtering mechanism. This pre-filtering regex allowed me to quickly check if the line \u003cem\u003emight\u003c/em\u003e be a possible candidate, without running the full regex on it. Skipping lines that do not match the expected pattern significantly reduced the number of lines that had to be processed by the complete regex.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eRE_PRE_FILTER \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e re\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ecompile(\u003cspan style=\"color:#e6db74\"\u003er\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;.*\\.(o|obj)\\)?\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003enot\u003c/span\u003e RE_PRE_FILTER\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ematch\u003c/span\u003e(line):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"late-start-and-early-exit-mechanisms\"\u003eLate Start And Early Exit Mechanisms\u003c/h2\u003e\n\u003cp\u003eI analyzed the \u003ccode\u003e.map\u003c/code\u003e file format to identify a start condition and a termination condition for the processing. The script now skips processing any lines before or after the relevant sections, reducing the total number of lines that need to be processed.\u003c/p\u003e\n\u003ch1 id=\"results\"\u003eResults\u003c/h1\u003e\n\u003ch2 id=\"benchmark-analysis\"\u003eBenchmark Analysis\u003c/h2\u003e\n\u003cp\u003eHere’s a breakdown of how each individual optimization contributed to the total performance improvements:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: right\"\u003ePre-Filter\u003c/th\u003e\n          \u003cth style=\"text-align: right\"\u003eEarly Exit\u003c/th\u003e\n          \u003cth style=\"text-align: right\"\u003eOptimized Regex\u003c/th\u003e\n          \u003cth style=\"text-align: right\"\u003eAvg Milliseconds\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: right\"\u003e✅\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003e❌\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003e❌\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003e6023\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: right\"\u003e❌\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003e✅\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003e❌\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003e4672\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: right\"\u003e❌\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003e❌\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003e✅\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003e675\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"final-performance\"\u003eFinal Performance\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eanthony@linux:~/esp/esp-idf/tools$ time ./idf\u003cspan style=\"color:#ae81ff\"\u003e\\_\u003c/span\u003esize.py /tmp/firmware.map  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ereal    0m0.385s  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003euser    0m0.361s  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esys     0m0.024s\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eExecution time reduced from 19.44 seconds to \u003cstrong\u003e0.385 seconds\u003c/strong\u003e!\u003c/p\u003e\n\u003ch1 id=\"real-world-impact\"\u003eReal-World Impact\u003c/h1\u003e\n\u003cp\u003eThese optimizations made it feasible to run \u003ccode\u003eidf_size.py\u003c/code\u003e \u003cem\u003eafter every build\u003c/em\u003e, saving developers countless hours and enabling faster feedback loops. I then created informative visual representations for developers to easily see where the memory was being allocated, and running it after every build meant the developers could instantly see how each change affected the resulting firmware.\u003c/p\u003e\n\u003ch2 id=\"memory-usage-visualizations\"\u003eMemory Usage Visualizations\u003c/h2\u003e\n\u003cp\u003eHere are a few examples of what my final product looked like after each compilation:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blogs/python-50x/mem_usage_1.webp\" alt=\"Memory Usage Visualization 1\"\u003e\n\u003cbr/\u003e\n\u003cbr/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blogs/python-50x/mem_usage_2.webp\" alt=\"Memory Usage Visualization 2\"\u003e\n\u003cbr/\u003e\n\u003cbr/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blogs/python-50x/mem_usage_3.webp\" alt=\"Memory Usage Visualization 3\"\u003e\n\u003cbr/\u003e\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eThe optimizations applied to \u003ccode\u003eidf_size.py\u003c/code\u003e have transformed it from a slow, frustrating tool to a fast and efficient solution for analyzing memory usage. The dramatic reduction in execution time highlights the impact of targeted optimizations.\u003c/p\u003e\n\u003cp\u003eFor further details and code changes, check out \u003ca href=\"https://github.com/espressif/esp-idf/pull/4518\"\u003ePR #4518\u003c/a\u003e.\u003c/p\u003e\n","description":"","image":"/images/blogs/python-50x/python-50x.webp","permalink":"https://ajcasagrande.dev/blogs/python-50x-performance/","title":"How I Made an Open Source Python Script Run 50x Faster"}]